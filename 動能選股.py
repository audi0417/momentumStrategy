# -*- coding: utf-8 -*-
"""動能選股(Github_Actions_部署版本).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LYAW6Gw0bHxVbj6iDLBnOUK_ZUz6tfwc
"""

MIN_DATA_LENGTH = 90
MIN_MOMENTUM = 7
MIN_TURNOVER = 500000000  # 5億成交量

import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import pandas as pd
import requests
from bs4 import BeautifulSoup
import numpy as np
import time
import yfinance as yf
from tqdm import tqdm
import mplfinance as mpf
#from talib.abstract import *
import datetime
import logging
import os
import json
import datetime
import requests
from urllib3.util.retry import Retry
from requests.adapters import HTTPAdapter
import certifi

def get_taiwan_datetime():
    """獲取台灣時區的當前日期時間"""
    from datetime import datetime, timezone, timedelta
    tw_timezone = timezone(timedelta(hours=8))
    return datetime.now(tw_timezone)

def get_current_trading_date():
    """獲取當前交易日期（格式：YYYY-MM-DD）"""
    return get_taiwan_datetime().strftime("%Y-%m-%d")

def get_holiday_schedule():
    """從 TWSE API 獲取假日資料"""
    try:
        url = "https://openapi.twse.com.tw/v1/holidaySchedule/holidaySchedule"
        response = requests.get(url)
        if response.status_code == 200:
            data = response.json()
            # 印出返回數據格式以便調試
            if data and len(data) > 0:
                print(f"假日資料獲取成功，共 {len(data)} 筆")
                print(f"假日數據格式範例: {data[0]}")
            return data
        else:
            print(f"獲取假日資料失敗: {response.status_code}")
            return []
    except Exception as e:
        print(f"獲取假日資料時發生錯誤：{str(e)}")
        return []
def get_previous_trading_day(current_date=None):
    """獲取前一個交易日"""
    if current_date is None:
        current_date = get_current_trading_date()

    current = datetime.datetime.strptime(current_date, "%Y-%m-%d")

    # 獲取假日資料
    holiday_schedule = get_holiday_schedule()

    # 如果是週一，預設前一交易日為上週五
    if current.weekday() == 0:  # 週一
        days_to_subtract = 3  # 回到上週五
    else:
        days_to_subtract = 1  # 其他工作日往前一天

    # 尋找前一個非假日、非週末的日期
    for i in range(days_to_subtract, days_to_subtract + 10):  # 最多往前找10天
        previous_date = current - datetime.timedelta(days=i)
        previous_date_str = previous_date.strftime("%Y-%m-%d")
        if not is_holiday(previous_date, holiday_schedule) and previous_date.weekday() < 5:
            return previous_date_str

    # 如果找不到，返回預設的前一天
    return (current - datetime.timedelta(days=days_to_subtract)).strftime("%Y-%m-%d")

def is_holiday(date, holiday_schedule):
    """檢查是否為假日"""
    # 將日期轉換為不同格式以匹配API可能的格式
    formats = [
        f"1{date.strftime('%y%m%d')}",  # 1250304
        date.strftime("%Y%m%d"),         # 20250304
        date.strftime("%Y/%m/%d"),       # 2025/03/04
        f"{date.year - 1911}/{date.month:02d}/{date.day:02d}"  # 114/03/04 (民國年)
    ]

    for holiday in holiday_schedule:
        holiday_date = holiday.get("Date", "")
        if any(holiday_date == fmt for fmt in formats):
            return True

    return False

def get_last_trading_day(current_date, holiday_schedule):
    """獲取前一個交易日"""
    try:
        current = datetime.datetime.strptime(current_date, "%Y-%m-%d")

        # 如果是週一，預設前一交易日是上週五
        if current.weekday() == 0:  # 週一
            days_to_subtract = 3  # 回到上週五
        else:
            days_to_subtract = 1  # 其他工作日往前一天

        # 尋找前一個交易日
        for i in range(1, 10):  # 最多往前找10天
            previous_date = current - datetime.timedelta(days=i)
            previous_date_str = previous_date.strftime("%Y-%m-%d")

            # 檢查是否為週末
            if previous_date.weekday() >= 5:
                continue  # 週末跳過

            # 檢查是否為假日
            is_holiday = False
            for holiday in holiday_schedule:
                # 嘗試多種日期格式匹配
                holiday_date = holiday.get("Date", "")
                formatted_dates = [
                    f"1{previous_date.strftime('%y%m%d')}",  # 1250304
                    previous_date.strftime("%Y%m%d"),        # 20250304
                    previous_date.strftime("%Y/%m/%d")       # 2025/03/04
                ]

                if holiday_date in formatted_dates:
                    is_holiday = True
                    break

            if not is_holiday:
                return previous_date_str  # 找到前一個交易日

        # 如果沒找到合適的日期，返回預設值（往前一天或三天）
        default_previous_date = current - datetime.timedelta(days=days_to_subtract)
        return default_previous_date.strftime("%Y-%m-%d")

    except Exception as e:
        print(f"獲取前一交易日時發生錯誤：{str(e)}")
        # 發生錯誤時，嘗試最簡單的方法 - 往前一個工作日
        try:
            if current.weekday() == 0:  # 週一
                return (current - datetime.timedelta(days=3)).strftime("%Y-%m-%d")
            else:
                return (current - datetime.timedelta(days=1)).strftime("%Y-%m-%d")
        except:
            # 如果一切都失敗，返回None
            return None

def load_stock_data():
    """從 GitHub 儲存庫中加載股票數據JSON"""
    file_path = 'stocks_data.json'

    if os.path.exists(file_path):
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except json.JSONDecodeError:
            print("JSON 文件格式錯誤，創建新文件")

    # 如果文件不存在或格式錯誤，則創建新的數據結構
    return {
        "last_update": datetime.datetime.now().strftime("%Y-%m-%d"),
        "stocks": {}
    }

def save_stock_data(data):
    """保存股票數據到 GitHub 儲存庫中的 JSON 文件"""
    file_path = 'stocks_data.json'
    with open(file_path, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=2)
    print(f"已保存數據到 {file_path}")


def update_momentum_stocks(momentum_stocks):
    """更新動能股票記錄，計算累積天數"""
    # 獲取台灣時間
    taiwan_now = get_taiwan_datetime()
    current_date = get_current_trading_date()

    # 獲取假日資料
    holiday_schedule = get_holiday_schedule()
    if not holiday_schedule:
        print("無法獲取假日資料，將使用簡單的週末判斷")
        holiday_schedule = []

    # 關鍵修改：使用前一個交易日作為信號日期
    # 因為凌晨執行時，最新數據實際上是前一個交易日的
    last_trading_day = get_previous_trading_day(current_date)
    signal_date = last_trading_day  # 用前一交易日作為信號日期

    print(f"今日: {current_date}, 信號日期: {signal_date}")

    # 加載現有數據
    data = load_stock_data()

    # 股票代號列表，用於檢查哪些股票不再出現
    current_stock_ids = set(momentum_stocks.keys())

    # 更新數據時使用信號日期而非當前日期
    for stock_id, momentum in momentum_stocks.items():
        stock_name = all_stock.loc[all_stock["股票代號"]==stock_id, "股票名稱"].values[0]

        if stock_id in data["stocks"]:
            # 檢查記錄的上次信號日期
            previous_signal_date = data["stocks"][stock_id]["last_signal_date"]

            # 判斷是否為連續交易日
            is_consecutive = is_consecutive_trading_day(previous_signal_date, signal_date, holiday_schedule)

            if is_consecutive:
                data["stocks"][stock_id]["days"] += 1
                print(f"股票 {stock_id} 連續出現 {data['stocks'][stock_id]['days']} 天")
            else:
                data["stocks"][stock_id]["days"] = 1
                print(f"股票 {stock_id} 重新出現，重設為 1 天")

            # 更新信號日期
            data["stocks"][stock_id]["momentum"] = float(momentum)
            data["stocks"][stock_id]["last_signal_date"] = signal_date
        else:
            # 新增記錄
            data["stocks"][stock_id] = {
                "stock_name": stock_name,
                "momentum": float(momentum),
                "days": 1,
                "last_signal_date": signal_date  # 使用信號日期
            }
            print(f"新增股票 {stock_id} {stock_name}")

    # 移除不再出現信號的股票
    stocks_to_remove = []
    for stock_id in data["stocks"]:
        if stock_id not in current_stock_ids:
            stocks_to_remove.append(stock_id)

    for stock_id in stocks_to_remove:
        stock_name = data["stocks"][stock_id]["stock_name"]
        print(f"移除不再出現信號的股票: {stock_id} {stock_name}")
        del data["stocks"][stock_id]

    # 更新最後更新時間
    data["last_update"] = current_date

    # 保存更新後的數據
    save_stock_data(data)

    return data


def is_consecutive_trading_day(earlier_date, later_date, holiday_schedule):
    """
    判斷兩個日期是否為連續交易日
    參數:
    earlier_date - 較早的日期 (格式: YYYY-MM-DD)
    later_date - 較晚的日期 (格式: YYYY-MM-DD)
    holiday_schedule - 假日資料
    """
    try:
        # 如果日期相同，認為是連續的
        if earlier_date == later_date:
            return True

        # 轉換為日期物件
        earlier = datetime.datetime.strptime(earlier_date, "%Y-%m-%d").date()
        later = datetime.datetime.strptime(later_date, "%Y-%m-%d").date()

        # 如果later比earlier早，不是連續
        if later < earlier:
            return False

        # 獲取這兩個日期之間的所有日期
        delta = later - earlier
        if delta.days <= 0:
            # later_date不應早於earlier_date
            return False

        # 檢查中間的每一天是否為交易日
        date_range = [earlier + datetime.timedelta(days=i) for i in range(1, delta.days)]

        # 過濾掉所有非交易日（週末和假日）
        for date in date_range:
            # 如果是週末，跳過
            if date.weekday() >= 5:
                continue

            # 如果是假日，跳過
            if is_holiday(date, holiday_schedule):
                continue

            # 如果找到交易日，則不是連續的
            return False

        # 如果中間沒有交易日，說明是連續的交易日
        return True

    except Exception as e:
        print(f"判斷連續交易日時出錯: {str(e)}")
        # 出錯時保守處理，返回False
        return False

def filter_stocks_by_condition(stock_index, condition_function, condition_args=None, min_value=None):
    """通用股票篩選函數"""
    filtered_stocks = {}
    skipped_stocks = {
        "length": 0,
        "indicator_null": 0,
        "below_threshold": 0,
        "turnover_error": 0,
        "turnover_low": 0
    }

    for stock_num, df in stock_index.items():
        # 檢查數據長度
        if len(df) < MIN_DATA_LENGTH:
            skipped_stocks["length"] += 1
            continue

        # 計算指標
        if condition_args:
            indicator_value = condition_function(df, **condition_args)
        else:
            indicator_value = condition_function(df)

        # 檢查指標值
        if indicator_value is None:
            skipped_stocks["indicator_null"] += 1
            continue

        # 檢查是否符合指標條件
        is_signal_valid = True  # 默認信號有效

        # 對於列表型指標（如RSI和MACD信號），檢查最後一個信號是否為買入信號
        if isinstance(indicator_value, list):
            if indicator_value[-1] != 100:  # 100表示買入信號
                is_signal_valid = False
                skipped_stocks["below_threshold"] += 1
                continue
        # 對於數值型指標（如動能），檢查是否大於min_value
        elif min_value is not None:
            if indicator_value <= min_value:
                is_signal_valid = False
                skipped_stocks["below_threshold"] += 1
                continue

        # 只有信號有效的股票才檢查成交量
        if is_signal_valid:
            try:
                turnover_str = get_turnover_batch(stock_num)
                turnover = int(turnover_str.replace(',', ''))
                if turnover > MIN_TURNOVER:
                    if isinstance(indicator_value, list):
                        filtered_stocks[stock_num] = indicator_value[-1]
                    else:
                        filtered_stocks[stock_num] = indicator_value
                else:
                    skipped_stocks["turnover_low"] += 1
                    print(f"股票 {stock_num} 成交量 {turnover_str} 低於閾值")
            except Exception as e:
                skipped_stocks["turnover_error"] += 1
                print(f"警告: {stock_num} 成交量檢查失敗 ({str(e)})")

    # 輸出篩選統計
    total = sum(skipped_stocks.values()) + len(filtered_stocks)
    print(f"\n篩選統計 (總計處理 {total} 支股票):")
    print(f"- 數據長度不足: {skipped_stocks['length']} 支")
    print(f"- 指標計算失敗: {skipped_stocks['indicator_null']} 支")
    print(f"- 未達指標閾值: {skipped_stocks['below_threshold']} 支")
    print(f"- 成交量取得失敗: {skipped_stocks['turnover_error']} 支")
    print(f"- 成交量過低: {skipped_stocks['turnover_low']} 支")
    print(f"- 符合條件: {len(filtered_stocks)} 支")

    return filtered_stocks

def print_filtering_results(stocks_dict, title, include_value=True, value_name="指標值", stock_data=None):
    """統一顯示篩選結果

    參數:
    stocks_dict - 股票字典或列表
    title - 顯示標題
    include_value - 是否包含指標值
    value_name - 指標名稱
    stock_data - 包含股票連續天數的數據 (可選)
    """
    console.print(f"\n{title}:")
    console.print("=" * 50)

    if not stocks_dict:
        console.print(f"[yellow]沒有找到符合{title}條件的股票[/yellow]")
        console.print("=" * 50)
        return

    # 顯示結果
    if isinstance(stocks_dict, dict):
        items = sorted(stocks_dict.items(), key=lambda x: x[1], reverse=True)
        count = len(items)
    else:
        items = [(stock, None) for stock in stocks_dict]
        count = len(stocks_dict)

    console.print(f"[green]共找到 {count} 支符合條件的股票:[/green]")

    for stock, value in items:
        stock_name = all_stock.loc[all_stock["股票代號"]==stock, "股票名稱"].values[0]
        turnover = get_turnover_batch(stock)
        turnover_formatted = format_number(turnover)

        if include_value and value is not None:

            days_info = ""
            try:
                if stock_data and "stocks" in stock_data and stock in stock_data["stocks"]:
                    if "days" in stock_data["stocks"][stock]:
                        days = stock_data["stocks"][stock]["days"]
                        days_info = f", 連續 {days} 天"
            except:
                pass

            console.print(f"股票代號: {stock} - {stock_name} ({value_name}: {value:.2f}%, 成交量: {turnover_formatted}{days_info})")
        else:
            console.print(f"股票代號: {stock} - {stock_name} (成交量: {turnover_formatted})")

    console.print("=" * 50)

def format_mail_content_with_days(momentum_stocks, rsi_stocks, macd_stocks, final_stocks, total_stocks, stock_data):
    sections = [
        {
            "title": "動能選股",
            "stocks": momentum_stocks,
            "is_dict": True,
            "value_name": "動能"
        },
        {
            "title": "RSI選股",
            "stocks": rsi_stocks,
            "is_dict": False,
            "value_name": None
        },
        {
            "title": "MACD選股",
            "stocks": macd_stocks,
            "is_dict": False,
            "value_name": None
        }
    ]

    content = f"""
股票篩選結果
======================

篩選概況
--------
- 篩選總數: {total_stocks} 支股票
"""

    # 處理各個篩選類別
    for section in sections:
        stocks = section["stocks"]
        title = section["title"]
        content += f"\n{title} (共 {len(stocks)} 支)\n-------------------"

        if stocks:
            content += "\n"
            if section["is_dict"]:
                sorted_stocks = sorted(stocks.items(), key=lambda x: x[1], reverse=True)
                for stock, value in sorted_stocks:
                    stock_name = all_stock.loc[all_stock["股票代號"]==stock, "股票名稱"].values[0]
                    turnover = format_number(get_turnover_batch(stock))
                    days = stock_data["stocks"][stock]["days"] if stock in stock_data["stocks"] else 1
                    content += f"• {stock} {stock_name}: {section['value_name']} {value:.2f}%, 成交量 {turnover}, 連續 {days} 天\n"
            else:
                for stock in stocks:
                    stock_name = all_stock.loc[all_stock["股票代號"]==stock, "股票名稱"].values[0]
                    turnover = format_number(get_turnover_batch(stock))
                    content += f"• {stock} {stock_name}: 成交量 {turnover}\n"

    # 最終篩選結果
    content += "\n最終篩選結果"
    content += "\n-----------------"
    if final_stocks:
        content += f"\n符合所有條件的股票 (共 {len(final_stocks)} 支):\n"
        for stock in final_stocks:
            stock_name = all_stock.loc[all_stock["股票代號"]==stock, "股票名稱"].values[0]
            momentum = momentum_stocks[stock]
            turnover = format_number(get_turnover_batch(stock))
            content += f"• {stock} {stock_name}\n"
            content += f"  動能: {momentum:.2f}%, 成交量: {turnover}\n"
    else:
        content += "\n本日無股票符合所有條件"

    return content

def send_mail(sender_email, app_password, receiver_email, content):
    try:
        msg = MIMEMultipart()
        msg['From'] = sender_email
        msg['To'] = receiver_email
        msg['Subject'] = f"股票篩選結果 - {get_current_trading_date()}"

        msg.attach(MIMEText(content, 'plain', 'utf-8'))

        server = smtplib.SMTP_SSL('smtp.gmail.com', 465)
        server.login(sender_email, app_password)
        server.send_message(msg)
        server.quit()

        print("郵件發送成功！")
    except Exception as e:
        print(f"發送郵件時發生錯誤：{str(e)}")

def robust_get(url, headers=None, params=None, max_retries=3, timeout=10):
    session = requests.Session()
    retries = Retry(
        total=max_retries,
        backoff_factor=1,
        status_forcelist=[500, 502, 503, 504],
        raise_on_status=False
    )
    session.mount('http://', HTTPAdapter(max_retries=retries))
    session.mount('https://', HTTPAdapter(max_retries=retries))

    headers = headers or {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)"
    }

    response = session.get(url, headers=headers, params=params, timeout=timeout, verify=certifi.where())
    response.raise_for_status()
    return response

# Commented out IPython magic to ensure Python compatibility.
logging.getLogger('yfinance').setLevel(logging.CRITICAL)
# %matplotlib inline
pd.options.mode.chained_assignment = None  # 關閉警告
#pd.options.mode.chained_assignment = 'warn'  # 開啟警告（預設值）

"""## 股票爬蟲"""

# 國內上市證券識別碼一覽表
url = "https://isin.twse.com.tw/isin/C_public.jsp?strMode=2"
res = robust_get(url)
# res = requests.get(url, verify=certifi.where())
TWSE_listed = pd.read_html(res.text)[0]
TWSE_listed.columns = list(TWSE_listed.iloc[0].values)
TWSE_listed = TWSE_listed.iloc[2:]
TWSE_listed.reset_index(drop=True, inplace=True)

# 國內上櫃證券識別碼一覽表
url = "https://isin.twse.com.tw/isin/C_public.jsp?strMode=4"
res = robust_get(url)
# res = requests.get(url, verify=certifi.where())  # ✅ 加上 verify
TPEX_listed = pd.read_html(res.text)[0]
TPEX_listed.columns = list(TPEX_listed.iloc[0].values)
TPEX_listed = TPEX_listed.iloc[2:]
TPEX_listed.reset_index(drop=True, inplace=True)

# 合併資料
all_stock = pd.concat([TWSE_listed, TPEX_listed])
all_stock.reset_index(drop=True, inplace=True)

#整理欄位
# 修改欄位處理方式
def process_stock_info(text):
    # 處理可能的 NaN 值
    if pd.isna(text):
        return None, None

    # 移除多餘的空格並分割
    parts = text.strip().split()
    if len(parts) >= 2:
        return parts[0], ' '.join(parts[1:])
    return None, None

# 處理股票代號和名稱
stock_info = all_stock["有價證券代號及名稱"].apply(process_stock_info)
stock_num = stock_info.apply(lambda x: x[0])
stock_name = stock_info.apply(lambda x: x[1])

# 插入新欄位
all_stock.insert(0, "股票代號", stock_num, True)
all_stock.insert(1, "股票名稱", stock_name, True)
all_stock = all_stock.drop(["有價證券代號及名稱"], axis=1)

# 只保留普通股
all_stock = all_stock[all_stock['CFICode']=="ESVUFR"]

# 移除股票代號或名稱為 None 的列
all_stock = all_stock.dropna(subset=['股票代號', '股票名稱'])

from concurrent.futures import ThreadPoolExecutor
import time
import random
from tqdm import tqdm
from rich.console import Console
from rich.progress import Progress, TextColumn, BarColumn, TaskProgressColumn

console = Console()
url = "https://www.tpex.org.tw/www/zh-tw/afterTrading/dailyQuotes"

date_str = datetime.datetime.now().strftime("%Y%m%d")

res = robust_get(url, params={
    "response": "json",
    "date": date_str
})
# res = requests.get(url, params={"response": "json","date": datetime.datetime.now().strftime("%Y%mm%dd")})
TPEx_turnover = res.json()['tables'][0]['data']

# 上市股票成交金額緩存
turnover_cache = {}

def get_turnover_batch(stock_num):
    """獲取單一股票的成交金額資料"""
    # 檢查快取
    if stock_num in turnover_cache:
        return turnover_cache[stock_num]

    try:
        # 取得股票市場類型
        market_type = all_stock.loc[all_stock["股票代號"]==stock_num, "市場別"].values[0]

        # 獲取當前日期和前一交易日
        current_date = get_current_trading_date()
        last_trading_day = get_previous_trading_day(current_date)

        print(f"獲取 {stock_num} 成交量 - 當前日期: {current_date}, 前一交易日: {last_trading_day}")

        if market_type == "上櫃":
            # 處理上櫃股票
            for stock in TPEx_turnover:
                if stock[0] == stock_num:
                    turnover = stock[10]  # 返回成交金額
                    turnover_cache[stock_num] = turnover  # 存入快取
                    return turnover
            raise ValueError(f"找不到上櫃股票 {stock_num} 的成交金額資料")

        else:  # 處理上市股票
            # 將日期轉換為API所需的格式
            last_trading_day_date = datetime.datetime.strptime(last_trading_day, "%Y-%m-%d").date()
            formatted_date = last_trading_day_date.strftime("%Y%m%d")

            print(f"API請求日期: {formatted_date}, 股票: {stock_num}")

            # 使用正確的API端點
            url = f"https://www.twse.com.tw/exchangeReport/STOCK_DAY"
            res = requests.get(url, params={
                "date": formatted_date,
                "stockNo": stock_num
            })

            if res.status_code == 200:
                res_json = res.json()

                if res_json["stat"] == "OK" and len(res_json["data"]) > 0:
                    # 仔細檢查返回的日期格式
                    sample_date = res_json["data"][0][0]
                    print(f"API返回的日期格式範例: {sample_date}")

                    # 尋找最近的交易日數據
                    today = get_taiwan_datetime()
                    for i in range(len(res_json["data"])-1, -1, -1):  # 從後往前找
                        date_str = res_json["data"][i][0]  # 日期格式: "114/02/27"

                        # 轉換台灣日期格式為西元日期
                        try:
                            year = int(date_str.split('/')[0]) + 1911  # 民國年轉西元年
                            month = int(date_str.split('/')[1])
                            day = int(date_str.split('/')[2])

                            data_date = datetime.date(year, month, day)

                            # 如果日期不是未來的日期，就使用這個數據
                            if data_date.toordinal() <= today.date().toordinal():
                                turnover = res_json["data"][i][2]  # 成交金額在索引2的位置
                                turnover_cache[stock_num] = turnover  # 存入快取
                                return turnover
                        except Exception as e:
                            print(f"日期解析錯誤: {date_str}, 錯誤: {str(e)}")
                            continue

                    # 如果沒有找到合適的日期，使用最後一個
                    turnover = res_json["data"][-1][2]
                    turnover_cache[stock_num] = turnover  # 存入快取
                    return turnover

            # 嘗試前一個月
            previous_month = last_trading_day_date.replace(day=1) - datetime.timedelta(days=1)
            formatted_date = previous_month.strftime("%Y%m%d")
            print(f"嘗試前一個月: {formatted_date}")

            res = requests.get(url, params={
                "date": formatted_date,
                "stockNo": stock_num
            })

            if res.status_code == 200:
                res_json = res.json()
                if res_json["stat"] == "OK" and len(res_json["data"]) > 0:
                    turnover = res_json["data"][-1][2]  # 使用最後一個交易日的成交金額
                    turnover_cache[stock_num] = turnover  # 存入快取
                    return turnover

            raise ValueError(f"找不到上市股票 {stock_num} 的成交金額資料")

    except Exception as e:
        raise Exception(f"獲取股票 {stock_num} 成交金額時發生錯誤: {str(e)}")

def get_stock_data(stock_info, max_retries=3, base_delay=1):
    stock_num, market_type = stock_info

    # 獲取正確的日期範圍
    end_date = get_current_trading_date()
    # 往前獲取足夠的數據進行分析
    start_date_obj = datetime.datetime.strptime(end_date, "%Y-%m-%d") - datetime.timedelta(days=180)
    start_date = start_date_obj.strftime("%Y-%m-%d")

    print(f"獲取股票 {stock_num} 數據 - 開始日期: {start_date}, 結束日期: {end_date}")

    for attempt in range(max_retries):
        try:
            time.sleep(base_delay + random.uniform(0, 1))

            if market_type == "上市":
                target = yf.Ticker(f"{stock_num}.TW")
            elif market_type == "上市臺灣創新板":
                target = yf.Ticker(f"{stock_num}.TW")
            else:
                target = yf.Ticker(f"{stock_num}.TWO")

            data = target.history(start=start_date, end=end_date)

            if len(data) == 0:
                if attempt == max_retries - 1:
                    console.print(f"[yellow]警告: {stock_num} 無法獲取資料[/yellow]")
                    return stock_num, None
                continue

            return stock_num, data

        except Exception as e:
            if attempt == max_retries - 1:
                console.print(f"[red]錯誤: {stock_num} - {str(e)}[/red]")
                return stock_num, None

            delay = base_delay * (1.5 ** attempt) + random.uniform(0, 0.5)
            time.sleep(delay)

    return stock_num, None

def parallel_get_stock_data(max_workers=8):
    import concurrent.futures

    batch_size = 30
    stock_info_list = [(num, all_stock.loc[all_stock["股票代號"]==num, "市場別"].values[0])
                       for num in all_stock["股票代號"]]

    stock_index = {}
    total_stocks = len(stock_info_list)

    with Progress(
        TextColumn("[progress.description]{task.description}"),
        BarColumn(complete_style="green"),
        TaskProgressColumn(),
        console=console,
        transient=True
    ) as progress:
        task = progress.add_task("[cyan]處理股票資料...", total=total_stocks)

        for i in range(0, len(stock_info_list), batch_size):
            batch = stock_info_list[i:i+batch_size]

            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                future_to_stock = {executor.submit(get_stock_data, stock_info): stock_info
                                 for stock_info in batch}

                for future in concurrent.futures.as_completed(future_to_stock):
                    stock_num, data = future.result()

                    if data is not None:
                        stock_index[stock_num] = data

                    progress.update(task, advance=1)

            time.sleep(0.2)

    return stock_index

def calculate_momentum(df):
    try:
        # 確保使用正確的欄位名稱
        close_prices = df['Close'] if 'Close' in df.columns else df['close']

        # 驗證數據有效性
        if len(close_prices) < 5:
            print("數據點不足，無法計算動能")
            return None

        # 檢查數據中是否有NaN
        if close_prices.isnull().any():
            print("數據中包含NaN值，可能影響動能計算準確性")

        momentum = (close_prices.iloc[-1] / close_prices.iloc[-5] - 1) * 100
        return momentum
    except Exception as e:
        print(f"計算動能時發生錯誤: {str(e)}")
        return None


def calculate_rsi(data, periods):
    # 計算價格變化
    df = data.copy()
    df['price_change'] = df['close'].diff()

    # 分別計算上漲和下跌
    df['gain'] = df['price_change'].apply(lambda x: x if x > 0 else 0)
    df['loss'] = df['price_change'].apply(lambda x: abs(x) if x < 0 else 0)

    # 計算平均上漲和下跌
    avg_gain = df['gain'].rolling(window=periods).mean()
    avg_loss = df['loss'].rolling(window=periods).mean()

    # 計算RS和RSI
    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))

    return rsi

def calculate_macd(data, fast_period=12, slow_period=26, signal_period=9):
    # 計算快線和慢線的EMA
    fast_ema = data['close'].ewm(span=fast_period, adjust=False).mean()
    slow_ema = data['close'].ewm(span=slow_period, adjust=False).mean()

    # 計算MACD線
    macd_line = fast_ema - slow_ema

    # 計算信號線
    signal_line = macd_line.ewm(span=signal_period, adjust=False).mean()

    # 計算柱狀圖
    histogram = macd_line - signal_line

    return pd.DataFrame({
        'macd': macd_line,
        'macdsignal': signal_line,
        'macdhist': histogram
    })

def Signal_rsi(data, shortTern, longTern):
    try:
        df = data.copy()
        df.columns = df.columns.str.lower()

        Signal = [0]
        shortRSI = calculate_rsi(df, shortTern)
        longRSI = calculate_rsi(df, longTern)

        for i in range(1, len(longRSI)):
            B_shortRSI = shortRSI.iloc[i-2]
            B_longRSI = longRSI.iloc[i-2]
            L_shortRSI = shortRSI.iloc[i-1]
            L_longRSI = longRSI.iloc[i-1]
            t_shortRSI = shortRSI.iloc[i]
            t_longRSI = longRSI.iloc[i]

            if not (pd.isna(L_shortRSI) or pd.isna(L_longRSI)):
                if B_longRSI > B_shortRSI and L_longRSI > L_shortRSI and t_longRSI > t_shortRSI:
                    if (B_longRSI - B_shortRSI >= L_longRSI - L_shortRSI and
                        L_longRSI - L_shortRSI > t_longRSI - t_shortRSI and
                        L_shortRSI < t_shortRSI and B_shortRSI < L_shortRSI):
                        Signal.append(100)
                    else:
                        Signal.append(0)
                elif B_longRSI < B_shortRSI and L_longRSI < L_shortRSI and t_longRSI < t_shortRSI:
                    if (B_shortRSI - B_longRSI >= L_shortRSI - L_longRSI and
                        L_shortRSI - L_longRSI > t_shortRSI - t_longRSI and
                        L_shortRSI > t_shortRSI and B_shortRSI > L_shortRSI):
                        Signal.append(-100)
                    else:
                        Signal.append(0)
                else:
                    Signal.append(0)
            else:
                Signal.append(0)
        return Signal

    except Exception as e:
        print(f"計算RSI信號時發生錯誤: {str(e)}")
        return None

def Signal_macd(data, fastperiod=12, slowperiod=26, signalperiod=9):
    try:
        df = data.copy()
        df.columns = df.columns.str.lower()

        Signal = [0]
        macd = calculate_macd(df, fastperiod, slowperiod, signalperiod)

        for i in range(1, len(macd)):
            BeforeMACD = macd['macdsignal'].iloc[i-2]
            BeforeDIF = macd['macd'].iloc[i-2]
            LastMACD = macd['macdsignal'].iloc[i-1]
            LastDIF = macd['macd'].iloc[i-1]
            ThisMACD = macd['macdsignal'].iloc[i]
            ThisDIF = macd['macd'].iloc[i]

            if not (pd.isna(LastMACD) or pd.isna(LastDIF)):
                if BeforeMACD > BeforeDIF and LastMACD > LastDIF and ThisMACD > ThisDIF:
                    if (BeforeMACD - BeforeDIF >= LastMACD - LastDIF and
                        LastMACD - LastDIF > ThisMACD - ThisDIF and
                        LastDIF < ThisDIF and BeforeDIF < LastDIF):
                        Signal.append(100)
                    else:
                        Signal.append(0)
                elif BeforeMACD < BeforeDIF and LastMACD < LastDIF and ThisMACD < ThisDIF:
                    if (BeforeDIF - BeforeMACD >= LastDIF - LastMACD and
                        LastDIF - LastMACD > ThisDIF - ThisMACD and
                        LastDIF > ThisDIF and BeforeDIF > LastDIF):
                        Signal.append(-100)
                    else:
                        Signal.append(0)
                else:
                    Signal.append(0)
            else:
                Signal.append(0)

        return Signal

    except Exception as e:
        print(f"計算MACD信號時發生錯誤: {str(e)}")
        return None

def format_number(number):
    try:
        # 將字串轉為整數並格式化
        if isinstance(number, str):
            number = int(number.replace(',', ''))
        return f"{number:,d}"
    except Exception as e:
        return str(number)

def main():
    try:
        # 日期檢查和調試信息
        taiwan_now = get_taiwan_datetime()         # 獲取台灣完整時間對象
        current_date = get_current_trading_date()  # 獲取台灣日期字符串 (YYYY-MM-DD)
        previous_trading_day = get_previous_trading_day()  # 獲取前一交易日

        console.print(f"[cyan]系統檢查[/cyan]")
        console.print(f"台灣時間: {taiwan_now}")
        console.print(f"當前日期: {current_date}")
        console.print(f"前一交易日: {previous_trading_day}")
        console.print(f"星期幾: {taiwan_now.weekday() + 1} (1=週一, 7=週日)")
        console.print("=" * 50)

        # 檢查假日數據
        holiday_schedule = get_holiday_schedule()
        if holiday_schedule:
            console.print(f"假日資料獲取成功, 共 {len(holiday_schedule)} 筆")
            if len(holiday_schedule) > 0:
                console.print(f"假日資料範例: {holiday_schedule[0]}")

                # 檢查當天是否為國定假日
                current_date_obj = taiwan_now.date()
                is_today_holiday = is_holiday(current_date_obj, holiday_schedule)

                if is_today_holiday:
                    console.print(f"[yellow]今日 {current_date} 為國定假日，程序終止執行[/yellow]")
                    return

                # 檢查是否為週末
                if taiwan_now.weekday() >= 5:  # 5=星期六, 6=星期日
                    console.print(f"[yellow]今日 {current_date} 為週末，程序終止執行[/yellow]")
                    return

                console.print(f"[green]今日 {current_date} 為交易日，程序繼續執行[/green]")
        else:
            console.print("[yellow]警告: 無法獲取假日資料[/yellow]")
        console.print("=" * 50)

        # 1. 獲取股票資料
        console.print("[cyan]開始獲取股票資料...[/cyan]")
        stock_index = parallel_get_stock_data(max_workers=3)
        if isinstance(stock_index, list):
            stock_index = dict(stock_index)

        if not stock_index:
            console.print("[red]錯誤: 未能成功獲取任何股票資料[/red]")
            return
        console.print(f"[green]成功獲取 {len(stock_index)} 支股票的資料[/green]")
        console.print("=" * 50)

        # 2. 動能篩選
        console.print("\n[cyan]開始進行動能篩選...[/cyan]")
        momentum_stocks = filter_stocks_by_condition(
            stock_index,
            calculate_momentum,
            min_value=MIN_MOMENTUM
        )

        # 更新動能股票連續天數
        console.print("\n[cyan]開始更新動能股票連續天數...[/cyan]")
        updated_stock_data = update_momentum_stocks(momentum_stocks)

        print_filtering_results(
            momentum_stocks,
            "動能篩選結果",
            include_value=True,
            value_name="動能值",
            stock_data=updated_stock_data  # 傳入股票數據
        )

        # 3. RSI篩選
        console.print("\n[cyan]開始進行RSI篩選...[/cyan]")
        rsi_stocks = filter_stocks_by_condition(
            stock_index,
            Signal_rsi,
            condition_args={"shortTern": 5, "longTern": 80}
        )

        # 輸出RSI篩選結果
        print_filtering_results(
            rsi_stocks,
            "RSI篩選結果",
            include_value=False,
            stock_data=updated_stock_data  # 傳入股票數據
        )

        # 4. MACD篩選
        console.print("\n[cyan]開始進行MACD篩選...[/cyan]")
        macd_stocks = filter_stocks_by_condition(
            stock_index,
            Signal_macd,
            condition_args={"fastperiod": 12, "slowperiod": 26, "signalperiod": 9}
        )

        # 輸出MACD篩選結果
        print_filtering_results(
            macd_stocks,
            "MACD篩選結果",
            include_value=False,
            stock_data=updated_stock_data  # 傳入股票數據
        )

        # 5. 最終篩選結果
        console.print("\n[cyan]最終篩選結果:[/cyan]")
        console.print("=" * 50)

        # 取得同時符合三個條件的股票
        final_qualified_stocks = [
            stock for stock in momentum_stocks
            if stock in rsi_stocks and stock in macd_stocks
        ]

        if final_qualified_stocks:
            console.print(f"[green]共找到 {len(final_qualified_stocks)} 支符合所有條件的股票:[/green]")
            for stock in final_qualified_stocks:
                stock_name = all_stock.loc[all_stock["股票代號"]==stock, "股票名稱"].values[0]
                momentum = momentum_stocks[stock]
                turnover = get_turnover_batch(stock)
                turnover_formatted = format_number(turnover)
                console.print(f"\n股票代號: {stock} - {stock_name}")
                console.print(f"  動能值: {momentum:.2f}%, 成交量: {turnover_formatted}")
        else:
            console.print("[yellow]沒有找到符合所有條件的股票[/yellow]")

        # 6. 發送郵件
        mail_content = format_mail_content_with_days(
            momentum_stocks,
            rsi_stocks,
            macd_stocks,
            final_qualified_stocks,
            len(stock_index),
            updated_stock_data
        )

        sender_email = os.getenv("SENDER_EMAIL")
        app_password = os.getenv("APP_PASSWORD")
        receiver_email = os.getenv("RECIVER_EMAIL")
        send_mail(sender_email, app_password, receiver_email, mail_content)

    except Exception as e:
        console.print(f"[red]執行過程發生錯誤: {str(e)}[/red]")

    finally:
        console.print("\n[green]程式執行完成[/green]")

if __name__ == "__main__":
    try:
        print("程式開始執行...")
        print("-" * 50)
        main()
    except KeyboardInterrupt:
        print("\n程式被使用者中斷")
    except Exception as e:
        print(f"\n程式執行時發生未預期的錯誤: {str(e)}")
