# -*- coding: utf-8 -*-
"""動能選股(Github Actions 部署版本)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BPiBju0KvLRblu5N93PAVE3Fn2hCiz62
"""

MIN_DATA_LENGTH = 126
MIN_MOMENTUM = 7
MIN_TURNOVER = 500000000  # 5億成交量

import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import pandas as pd
import requests
from bs4 import BeautifulSoup
import numpy as np
import time
import yfinance as yf
from tqdm import tqdm
import mplfinance as mpf
#from talib.abstract import *
import datetime
import logging
import os
import json
import datetime
import requests

def get_holiday_schedule():
    """從 TWSE API 獲取假日資料"""
    try:
        url = "https://openapi.twse.com.tw/v1/holidaySchedule/holidaySchedule"
        response = requests.get(url)
        if response.status_code == 200:
            return response.json()
        else:
            print(f"獲取假日資料失敗: {response.status_code}")
            return None
    except Exception as e:
        print(f"獲取假日資料時發生錯誤：{str(e)}")
        return None

def is_trading_day(date_str, holiday_schedule):
    """判斷是否為交易日"""
    try:
        date = datetime.datetime.strptime(date_str, "%Y-%m-%d")
        # 週末不交易
        if date.weekday() >= 5:
            return False

        # 轉換日期格式以匹配假日資料 (YYYYMMDD -> 1YYMMDD)
        formatted_date = f"1{date.strftime('%y%m%d')}"

        # 檢查是否為假日
        for holiday in holiday_schedule:
            if holiday["Date"] == formatted_date:
                return False

        return True
    except Exception as e:
        print(f"檢查交易日時發生錯誤：{str(e)}")
        return False

def get_last_trading_day(current_date, holiday_schedule):
    """獲取前一個交易日"""
    try:
        current = datetime.datetime.strptime(current_date, "%Y-%m-%d")

        # 往前找最多30天，確保能找到前一個交易日
        for i in range(1, 30):
            previous_date = current - datetime.timedelta(days=i)
            previous_date_str = previous_date.strftime("%Y-%m-%d")
            if is_trading_day(previous_date_str, holiday_schedule):
                return previous_date_str

        return None
    except Exception as e:
        print(f"獲取前一交易日時發生錯誤：{str(e)}")
        return None

def load_stock_data():
    """從 GitHub 儲存庫中加載股票數據JSON"""
    file_path = 'stocks_data.json'

    if os.path.exists(file_path):
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except json.JSONDecodeError:
            print("JSON 文件格式錯誤，創建新文件")

    # 如果文件不存在或格式錯誤，則創建新的數據結構
    return {
        "last_update": datetime.datetime.now().strftime("%Y-%m-%d"),
        "stocks": {}
    }

def save_stock_data(data):
    """保存股票數據到 GitHub 儲存庫中的 JSON 文件"""
    file_path = 'stocks_data.json'
    with open(file_path, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=2)
    print(f"已保存數據到 {file_path}")

def update_momentum_stocks(momentum_stocks):
    """更新動能股票記錄，計算累積天數"""
    today = datetime.datetime.now().strftime("%Y-%m-%d")

    # 獲取假日資料
    holiday_schedule = get_holiday_schedule()
    if not holiday_schedule:
        print("無法獲取假日資料，將使用簡單的週末判斷")
        holiday_schedule = []

    # 獲取前一個交易日
    last_trading_day = get_last_trading_day(today, holiday_schedule)
    print(f"今日: {today}, 前一交易日: {last_trading_day}")

    # 加載現有數據
    data = load_stock_data()

    # 股票代號列表，用於檢查哪些股票不再出現
    current_stock_ids = set(momentum_stocks.keys())

    # 更新數據
    for stock_id, momentum in momentum_stocks.items():
        stock_name = all_stock.loc[all_stock["股票代號"]==stock_id, "股票名稱"].values[0]

        if stock_id in data["stocks"]:
            # 檢查是否連續出現
            if data["stocks"][stock_id]["last_signal_date"] == last_trading_day:
                data["stocks"][stock_id]["days"] += 1
                print(f"股票 {stock_id} 連續出現 {data['stocks'][stock_id]['days']} 天")
            else:
                data["stocks"][stock_id]["days"] = 1
                print(f"股票 {stock_id} 重新出現，重設為 1 天")

            # 更新其他數據
            data["stocks"][stock_id]["momentum"] = float(momentum)
            data["stocks"][stock_id]["last_signal_date"] = today
        else:
            # 新增記錄
            data["stocks"][stock_id] = {
                "stock_name": stock_name,
                "momentum": float(momentum),
                "days": 1,
                "last_signal_date": today
            }
            print(f"新增股票 {stock_id} {stock_name}")

    # 移除不再出現信號的股票
    stocks_to_remove = []
    for stock_id in data["stocks"]:
        if stock_id not in current_stock_ids:
            stocks_to_remove.append(stock_id)

    for stock_id in stocks_to_remove:
        stock_name = data["stocks"][stock_id]["stock_name"]
        print(f"移除不再出現信號的股票: {stock_id} {stock_name}")
        del data["stocks"][stock_id]

    # 更新最後更新時間
    data["last_update"] = today

    # 保存更新後的數據
    save_stock_data(data)

    return data

def filter_stocks_by_condition(stock_index, condition_function, condition_args=None, min_value=None):
    """通用股票篩選函數"""
    filtered_stocks = {}
    skipped_stocks = {
        "length": 0,
        "indicator_null": 0,
        "below_threshold": 0,
        "turnover_error": 0,
        "turnover_low": 0
    }

    for stock_num, df in stock_index.items():
        # 檢查數據長度
        if len(df) < MIN_DATA_LENGTH:
            skipped_stocks["length"] += 1
            continue

        # 計算指標
        if condition_args:
            indicator_value = condition_function(df, **condition_args)
        else:
            indicator_value = condition_function(df)

        # 檢查指標值
        if indicator_value is None:
            skipped_stocks["indicator_null"] += 1
            continue

        # 檢查是否符合指標條件
        is_signal_valid = True  # 默認信號有效

        # 對於列表型指標（如RSI和MACD信號），檢查最後一個信號是否為買入信號
        if isinstance(indicator_value, list):
            if indicator_value[-1] != 100:  # 100表示買入信號
                is_signal_valid = False
                skipped_stocks["below_threshold"] += 1
                continue
        # 對於數值型指標（如動能），檢查是否大於min_value
        elif min_value is not None:
            if indicator_value <= min_value:
                is_signal_valid = False
                skipped_stocks["below_threshold"] += 1
                continue

        # 只有信號有效的股票才檢查成交量
        if is_signal_valid:
            try:
                turnover_str = get_turnover_batch(stock_num)
                turnover = int(turnover_str.replace(',', ''))
                if turnover > MIN_TURNOVER:
                    if isinstance(indicator_value, list):
                        filtered_stocks[stock_num] = indicator_value[-1]
                    else:
                        filtered_stocks[stock_num] = indicator_value
                else:
                    skipped_stocks["turnover_low"] += 1
                    print(f"股票 {stock_num} 成交量 {turnover_str} 低於閾值")
            except Exception as e:
                skipped_stocks["turnover_error"] += 1
                print(f"警告: {stock_num} 成交量檢查失敗 ({str(e)})")

    # 輸出篩選統計
    total = sum(skipped_stocks.values()) + len(filtered_stocks)
    print(f"\n篩選統計 (總計處理 {total} 支股票):")
    print(f"- 數據長度不足: {skipped_stocks['length']} 支")
    print(f"- 指標計算失敗: {skipped_stocks['indicator_null']} 支")
    print(f"- 未達指標閾值: {skipped_stocks['below_threshold']} 支")
    print(f"- 成交量取得失敗: {skipped_stocks['turnover_error']} 支")
    print(f"- 成交量過低: {skipped_stocks['turnover_low']} 支")
    print(f"- 符合條件: {len(filtered_stocks)} 支")

    return filtered_stocks

def print_filtering_results(stocks_dict, title, include_value=True, value_name="指標值", stock_data=None):
    """統一顯示篩選結果

    參數:
    stocks_dict - 股票字典或列表
    title - 顯示標題
    include_value - 是否包含指標值
    value_name - 指標名稱
    stock_data - 包含股票連續天數的數據 (可選)
    """
    console.print(f"\n{title}:")
    console.print("=" * 50)

    if not stocks_dict:
        console.print(f"[yellow]沒有找到符合{title}條件的股票[/yellow]")
        console.print("=" * 50)
        return

    # 顯示結果
    if isinstance(stocks_dict, dict):
        items = sorted(stocks_dict.items(), key=lambda x: x[1], reverse=True)
        count = len(items)
    else:
        items = [(stock, None) for stock in stocks_dict]
        count = len(stocks_dict)

    console.print(f"[green]共找到 {count} 支符合條件的股票:[/green]")

    for stock, value in items:
        stock_name = all_stock.loc[all_stock["股票代號"]==stock, "股票名稱"].values[0]
        turnover = get_turnover_batch(stock)
        turnover_formatted = format_number(turnover)

        if include_value and value is not None:

            days_info = ""
            try:
                if stock_data and "stocks" in stock_data and stock in stock_data["stocks"]:
                    if "days" in stock_data["stocks"][stock]:
                        days = stock_data["stocks"][stock]["days"]
                        days_info = f", 連續 {days} 天"
            except:
                pass

            console.print(f"股票代號: {stock} - {stock_name} ({value_name}: {value:.2f}%, 成交量: {turnover_formatted}{days_info})")
        else:
            console.print(f"股票代號: {stock} - {stock_name} (成交量: {turnover_formatted})")

    console.print("=" * 50)

def format_mail_content_with_days(momentum_stocks, rsi_stocks, macd_stocks, final_stocks, total_stocks, stock_data):
    sections = [
        {
            "title": "動能選股",
            "stocks": momentum_stocks,
            "is_dict": True,
            "value_name": "動能"
        },
        {
            "title": "RSI選股",
            "stocks": rsi_stocks,
            "is_dict": False,
            "value_name": None
        },
        {
            "title": "MACD選股",
            "stocks": macd_stocks,
            "is_dict": False,
            "value_name": None
        }
    ]

    content = f"""
股票篩選結果
======================

篩選概況
--------
- 篩選總數: {total_stocks} 支股票
"""

    # 處理各個篩選類別
    for section in sections:
        stocks = section["stocks"]
        title = section["title"]
        content += f"\n{title} (共 {len(stocks)} 支)\n-------------------"

        if stocks:
            content += "\n"
            if section["is_dict"]:
                sorted_stocks = sorted(stocks.items(), key=lambda x: x[1], reverse=True)
                for stock, value in sorted_stocks:
                    stock_name = all_stock.loc[all_stock["股票代號"]==stock, "股票名稱"].values[0]
                    turnover = format_number(get_turnover_batch(stock))
                    days = stock_data["stocks"][stock]["days"] if stock in stock_data["stocks"] else 1
                    content += f"• {stock} {stock_name}: {section['value_name']} {value:.2f}%, 成交量 {turnover}, 連續 {days} 天\n"
            else:
                for stock in stocks:
                    stock_name = all_stock.loc[all_stock["股票代號"]==stock, "股票名稱"].values[0]
                    turnover = format_number(get_turnover_batch(stock))
                    content += f"• {stock} {stock_name}: 成交量 {turnover}\n"

    # 最終篩選結果
    content += "\n最終篩選結果"
    content += "\n-----------------"
    if final_stocks:
        content += f"\n符合所有條件的股票 (共 {len(final_stocks)} 支):\n"
        for stock in final_stocks:
            stock_name = all_stock.loc[all_stock["股票代號"]==stock, "股票名稱"].values[0]
            momentum = momentum_stocks[stock]
            turnover = format_number(get_turnover_batch(stock))
            content += f"• {stock} {stock_name}\n"
            content += f"  動能: {momentum:.2f}%, 成交量: {turnover}\n"
    else:
        content += "\n本日無股票符合所有條件"

    return content

def send_mail(sender_email, app_password, receiver_email, content):
    try:
        msg = MIMEMultipart()
        msg['From'] = sender_email
        msg['To'] = receiver_email
        msg['Subject'] = f"股票篩選結果 - {datetime.datetime.now().strftime('%Y-%m-%d')}"

        msg.attach(MIMEText(content, 'plain', 'utf-8'))

        server = smtplib.SMTP_SSL('smtp.gmail.com', 465)
        server.login(sender_email, app_password)
        server.send_message(msg)
        server.quit()

        print("郵件發送成功！")
    except Exception as e:
        print(f"發送郵件時發生錯誤：{str(e)}")

# Commented out IPython magic to ensure Python compatibility.
logging.getLogger('yfinance').setLevel(logging.CRITICAL)
# %matplotlib inline
pd.options.mode.chained_assignment = None  # 關閉警告
#pd.options.mode.chained_assignment = 'warn'  # 開啟警告（預設值）

"""## 股票爬蟲"""

#國內上市證卷辨識號碼一覽表
url = "https://isin.twse.com.tw/isin/C_public.jsp?strMode=2"
res = requests.get(url)
TWSE_listed = pd.read_html(res.text)[0]
# 設定column名稱
TWSE_listed.columns = list(TWSE_listed.iloc[0].values)
# 刪除第一行
TWSE_listed = TWSE_listed.iloc[2:]
TWSE_listed.reset_index(drop=True, inplace=True)

#國內上櫃證卷辨識號碼一覽表
url = "https://isin.twse.com.tw/isin/C_public.jsp?strMode=4"
res = requests.get(url)
TPEX_listed = pd.read_html(res.text)[0]
# 設定column名稱
TPEX_listed.columns = list(TPEX_listed.iloc[0].values)
# 刪除第一行
TPEX_listed = TPEX_listed.iloc[2:]
TPEX_listed.reset_index(drop=True, inplace=True)

# 刪除第一行並合併
TWSE_listed = TWSE_listed.iloc[2:]
TPEX_listed = TPEX_listed.iloc[2:]
all_stock = pd.concat([TWSE_listed, TPEX_listed])

all_stock.reset_index(drop=True, inplace=True)

#整理欄位
# 修改欄位處理方式
def process_stock_info(text):
    # 處理可能的 NaN 值
    if pd.isna(text):
        return None, None

    # 移除多餘的空格並分割
    parts = text.strip().split()
    if len(parts) >= 2:
        return parts[0], ' '.join(parts[1:])
    return None, None

# 處理股票代號和名稱
stock_info = all_stock["有價證券代號及名稱"].apply(process_stock_info)
stock_num = stock_info.apply(lambda x: x[0])
stock_name = stock_info.apply(lambda x: x[1])

# 插入新欄位
all_stock.insert(0, "股票代號", stock_num, True)
all_stock.insert(1, "股票名稱", stock_name, True)
all_stock = all_stock.drop(["有價證券代號及名稱"], axis=1)

# 只保留普通股
all_stock = all_stock[all_stock['CFICode']=="ESVUFR"]

# 移除股票代號或名稱為 None 的列
all_stock = all_stock.dropna(subset=['股票代號', '股票名稱'])

start_date = "2024-01-01"
end_date = datetime.datetime.now().strftime("%Y-%m-%d")
#end_date = "2024-12-31"

from concurrent.futures import ThreadPoolExecutor
import time
import random
from tqdm import tqdm
from rich.console import Console
from rich.progress import Progress, TextColumn, BarColumn, TaskProgressColumn

console = Console()
url = "https://www.tpex.org.tw/www/zh-tw/afterTrading/dailyQuotes"

res = requests.get(url, params={
        "response": "json",
        "date": datetime.datetime.now().strftime("%Y%mm%dd")
})
TPEx_turnover = res.json()['tables'][0]['data']

# 上市股票成交金額緩存
turnover_cache = {}

def get_turnover_batch(stock_num):
    """獲取單一股票的成交金額資料"""
    # 檢查快取
    if stock_num in turnover_cache:
        return turnover_cache[stock_num]

    try:
        # 取得股票市場類型
        market_type = all_stock.loc[all_stock["股票代號"]==stock_num, "市場別"].values[0]

        if market_type == "上櫃":
            # 處理上櫃股票 - 對於上櫃股票，成交金額在索引10的位置
            for stock in TPEx_turnover:
                if stock[0] == stock_num:
                    turnover = stock[10]  # 返回成交金額
                    turnover_cache[stock_num] = turnover  # 存入快取
                    return turnover
            raise ValueError(f"找不到上櫃股票 {stock_num} 的成交金額資料")

        else:  # 處理上市股票
            # 獲取假日資料
            holiday_schedule = get_holiday_schedule() or []

            # 獲取當前日期
            today = datetime.datetime.now()
            current_date_str = today.strftime("%Y-%m-%d")

            # 獲取前一個交易日
            last_trading_day = get_last_trading_day(current_date_str, holiday_schedule)
            if not last_trading_day:
                # 如果無法獲取前一交易日，使用當前月份的第一天
                last_trading_day_date = datetime.date(today.year, today.month, 1)
            else:
                last_trading_day_date = datetime.datetime.strptime(last_trading_day, "%Y-%m-%d").date()

            # 格式化為API所需的日期格式 YYYYMMDD
            formatted_date = last_trading_day_date.strftime("%Y%m%d")

            # 使用正確的API端點
            url = f"https://www.twse.com.tw/exchangeReport/STOCK_DAY"
            res = requests.get(url, params={
                "date": formatted_date,
                "stockNo": stock_num
            })

            if res.status_code == 200:
                res_json = res.json()
                if res_json["stat"] == "OK" and len(res_json["data"]) > 0:
                    # 尋找最近的交易日數據
                    for i in range(len(res_json["data"])-1, -1, -1):  # 從後往前找
                        date_str = res_json["data"][i][0]  # 日期格式: "114/02/27"
                        # 轉換台灣日期格式為西元日期
                        year = int(date_str.split('/')[0]) + 1911  # 民國年轉西元年
                        month = int(date_str.split('/')[1])
                        day = int(date_str.split('/')[2])

                        data_date = datetime.date(year, month, day)

                        # 如果日期不是未來的日期，就使用這個數據
                        if data_date.toordinal() <= today.date().toordinal():
                            turnover = res_json["data"][i][2]  # 成交金額在索引2的位置
                            turnover_cache[stock_num] = turnover  # 存入快取
                            return turnover

                    # 如果沒有找到合適的日期，使用最後一個
                    turnover = res_json["data"][-1][2]
                    turnover_cache[stock_num] = turnover  # 存入快取
                    return turnover

            # 如果API請求失敗，嘗試使用其他可能的日期格式
            if not res.ok or res_json.get("stat") != "OK":
                # 嘗試前一個月
                previous_month = last_trading_day_date.replace(day=1) - datetime.timedelta(days=1)
                formatted_date = previous_month.strftime("%Y%m%d")

                res = requests.get(url, params={
                    "date": formatted_date,
                    "stockNo": stock_num
                })

                if res.status_code == 200:
                    res_json = res.json()
                    if res_json["stat"] == "OK" and len(res_json["data"]) > 0:
                        turnover = res_json["data"][-1][2]  # 使用最後一個交易日的成交金額
                        turnover_cache[stock_num] = turnover  # 存入快取
                        return turnover

            raise ValueError(f"找不到上市股票 {stock_num} 的成交金額資料")

    except Exception as e:
        raise Exception(f"獲取股票 {stock_num} 成交金額時發生錯誤: {str(e)}")

def get_stock_data(stock_info, max_retries=3, base_delay=1):
    stock_num, market_type = stock_info

    for attempt in range(max_retries):
        try:
            time.sleep(base_delay + random.uniform(0, 1))

            if market_type == "上市":
                target = yf.Ticker(f"{stock_num}.TW")
            elif market_type == "上市臺灣創新板":
                target = yf.Ticker(f"{stock_num}.TW")
            else:
                target = yf.Ticker(f"{stock_num}.TWO")

            data = target.history(start=start_date, end=end_date)

            if len(data) == 0:
                if attempt == max_retries - 1:
                    console.print(f"[yellow]警告: {stock_num} 無法獲取資料[/yellow]")
                    return stock_num, None
                continue

            return stock_num, data

        except Exception as e:
            if attempt == max_retries - 1:
                console.print(f"[red]錯誤: {stock_num} - {str(e)}[/red]")
                return stock_num, None

            delay = base_delay * (1.5 ** attempt) + random.uniform(0, 0.5)
            time.sleep(delay)

    return stock_num, None

def parallel_get_stock_data(max_workers=5):
    import concurrent.futures

    batch_size = 50
    stock_info_list = [(num, all_stock.loc[all_stock["股票代號"]==num, "市場別"].values[0])
                       for num in all_stock["股票代號"]]

    stock_index = {}
    total_stocks = len(stock_info_list)

    with Progress(
        TextColumn("[progress.description]{task.description}"),
        BarColumn(complete_style="green"),
        TaskProgressColumn(),
        console=console,
        transient=True
    ) as progress:
        task = progress.add_task("[cyan]處理股票資料...", total=total_stocks)

        for i in range(0, len(stock_info_list), batch_size):
            batch = stock_info_list[i:i+batch_size]

            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                future_to_stock = {executor.submit(get_stock_data, stock_info): stock_info
                                 for stock_info in batch}

                for future in concurrent.futures.as_completed(future_to_stock):
                    stock_num, data = future.result()

                    if data is not None:
                        stock_index[stock_num] = data

                    progress.update(task, advance=1)

            time.sleep(0.2)

    return stock_index

def calculate_momentum(df):
    try:
        # 確保使用正確的欄位名稱
        close_prices = df['Close'] if 'Close' in df.columns else df['close']
        momentum = (close_prices.iloc[-1] / close_prices.iloc[-5] - 1) * 100
        return momentum
    except Exception as e:
        print(f"計算動能時發生錯誤: {str(e)}")
        return None
def calculate_rsi(data, periods):
    # 計算價格變化
    df = data.copy()
    df['price_change'] = df['close'].diff()

    # 分別計算上漲和下跌
    df['gain'] = df['price_change'].apply(lambda x: x if x > 0 else 0)
    df['loss'] = df['price_change'].apply(lambda x: abs(x) if x < 0 else 0)

    # 計算平均上漲和下跌
    avg_gain = df['gain'].rolling(window=periods).mean()
    avg_loss = df['loss'].rolling(window=periods).mean()

    # 計算RS和RSI
    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))

    return rsi

def calculate_macd(data, fast_period=12, slow_period=26, signal_period=9):
    # 計算快線和慢線的EMA
    fast_ema = data['close'].ewm(span=fast_period, adjust=False).mean()
    slow_ema = data['close'].ewm(span=slow_period, adjust=False).mean()

    # 計算MACD線
    macd_line = fast_ema - slow_ema

    # 計算信號線
    signal_line = macd_line.ewm(span=signal_period, adjust=False).mean()

    # 計算柱狀圖
    histogram = macd_line - signal_line

    return pd.DataFrame({
        'macd': macd_line,
        'macdsignal': signal_line,
        'macdhist': histogram
    })

def Signal_rsi(data, shortTern, longTern):
    try:
        df = data.copy()
        df.columns = df.columns.str.lower()

        Signal = [0]
        shortRSI = calculate_rsi(df, shortTern)
        longRSI = calculate_rsi(df, longTern)

        for i in range(1, len(longRSI)):
            B_shortRSI = shortRSI.iloc[i-2]
            B_longRSI = longRSI.iloc[i-2]
            L_shortRSI = shortRSI.iloc[i-1]
            L_longRSI = longRSI.iloc[i-1]
            t_shortRSI = shortRSI.iloc[i]
            t_longRSI = longRSI.iloc[i]

            if not (pd.isna(L_shortRSI) or pd.isna(L_longRSI)):
                if B_longRSI > B_shortRSI and L_longRSI > L_shortRSI and t_longRSI > t_shortRSI:
                    if (B_longRSI - B_shortRSI >= L_longRSI - L_shortRSI and
                        L_longRSI - L_shortRSI > t_longRSI - t_shortRSI and
                        L_shortRSI < t_shortRSI and B_shortRSI < L_shortRSI):
                        Signal.append(100)
                    else:
                        Signal.append(0)
                elif B_longRSI < B_shortRSI and L_longRSI < L_shortRSI and t_longRSI < t_shortRSI:
                    if (B_shortRSI - B_longRSI >= L_shortRSI - L_longRSI and
                        L_shortRSI - L_longRSI > t_shortRSI - t_longRSI and
                        L_shortRSI > t_shortRSI and B_shortRSI > L_shortRSI):
                        Signal.append(-100)
                    else:
                        Signal.append(0)
                else:
                    Signal.append(0)
            else:
                Signal.append(0)
        return Signal

    except Exception as e:
        print(f"計算RSI信號時發生錯誤: {str(e)}")
        return None

def Signal_macd(data, fastperiod=12, slowperiod=26, signalperiod=9):
    try:
        df = data.copy()
        df.columns = df.columns.str.lower()

        Signal = [0]
        macd = calculate_macd(df, fastperiod, slowperiod, signalperiod)

        for i in range(1, len(macd)):
            BeforeMACD = macd['macdsignal'].iloc[i-2]
            BeforeDIF = macd['macd'].iloc[i-2]
            LastMACD = macd['macdsignal'].iloc[i-1]
            LastDIF = macd['macd'].iloc[i-1]
            ThisMACD = macd['macdsignal'].iloc[i]
            ThisDIF = macd['macd'].iloc[i]

            if not (pd.isna(LastMACD) or pd.isna(LastDIF)):
                if BeforeMACD > BeforeDIF and LastMACD > LastDIF and ThisMACD > ThisDIF:
                    if (BeforeMACD - BeforeDIF >= LastMACD - LastDIF and
                        LastMACD - LastDIF > ThisMACD - ThisDIF and
                        LastDIF < ThisDIF and BeforeDIF < LastDIF):
                        Signal.append(100)
                    else:
                        Signal.append(0)
                elif BeforeMACD < BeforeDIF and LastMACD < LastDIF and ThisMACD < ThisDIF:
                    if (BeforeDIF - BeforeMACD >= LastDIF - LastMACD and
                        LastDIF - LastMACD > ThisDIF - ThisMACD and
                        LastDIF > ThisDIF and BeforeDIF > LastDIF):
                        Signal.append(-100)
                    else:
                        Signal.append(0)
                else:
                    Signal.append(0)
            else:
                Signal.append(0)

        return Signal

    except Exception as e:
        print(f"計算MACD信號時發生錯誤: {str(e)}")
        return None

def format_number(number):
    try:
        # 將字串轉為整數並格式化
        if isinstance(number, str):
            number = int(number.replace(',', ''))
        return f"{number:,d}"
    except Exception as e:
        return str(number)

def main():
    try:
        # 1. 獲取股票資料
        console.print("[cyan]開始獲取股票資料...[/cyan]")
        stock_index = parallel_get_stock_data(max_workers=3)

        if isinstance(stock_index, list):
            stock_index = dict(stock_index)

        if not stock_index:
            console.print("[red]錯誤: 未能成功獲取任何股票資料[/red]")
            return
        console.print(f"[green]成功獲取 {len(stock_index)} 支股票的資料[/green]")
        console.print("=" * 50)

        # 2. 動能篩選
        console.print("\n[cyan]開始進行動能篩選...[/cyan]")
        momentum_stocks = filter_stocks_by_condition(
            stock_index,
            calculate_momentum,
            min_value=MIN_MOMENTUM
        )

        # 更新動能股票連續天數
        console.print("\n[cyan]開始更新動能股票連續天數...[/cyan]")
        updated_stock_data = update_momentum_stocks(momentum_stocks)

        print_filtering_results(
            momentum_stocks,
            "動能篩選結果",
            include_value=True,
            value_name="動能值",
            stock_data=updated_stock_data  # 傳入股票數據
        )

        # 3. RSI篩選
        console.print("\n[cyan]開始進行RSI篩選...[/cyan]")
        rsi_stocks = filter_stocks_by_condition(
            stock_index,
            Signal_rsi,
            condition_args={"shortTern": 5, "longTern": 80}
        )

        # 輸出RSI篩選結果
        print_filtering_results(
            rsi_stocks,
            "RSI篩選結果",
            include_value=False,
            stock_data=updated_stock_data  # 傳入股票數據
        )

        # 4. MACD篩選
        console.print("\n[cyan]開始進行MACD篩選...[/cyan]")
        macd_stocks = filter_stocks_by_condition(
            stock_index,
            Signal_macd,
            condition_args={"fastperiod": 12, "slowperiod": 26, "signalperiod": 9}
        )

        # 輸出MACD篩選結果
        print_filtering_results(
            macd_stocks,
            "MACD篩選結果",
            include_value=False,
            stock_data=updated_stock_data  # 傳入股票數據
        )

        # 5. 最終篩選結果
        console.print("\n[cyan]最終篩選結果:[/cyan]")
        console.print("=" * 50)

        # 取得同時符合三個條件的股票
        final_qualified_stocks = [
            stock for stock in momentum_stocks
            if stock in rsi_stocks and stock in macd_stocks
        ]

        if final_qualified_stocks:
            console.print(f"[green]共找到 {len(final_qualified_stocks)} 支符合所有條件的股票:[/green]")
            for stock in final_qualified_stocks:
                stock_name = all_stock.loc[all_stock["股票代號"]==stock, "股票名稱"].values[0]
                momentum = momentum_stocks[stock]
                turnover = get_turnover_batch(stock)
                turnover_formatted = format_number(turnover)
                console.print(f"\n股票代號: {stock} - {stock_name}")
                console.print(f"  動能值: {momentum:.2f}%, 成交量: {turnover_formatted}")
        else:
            console.print("[yellow]沒有找到符合所有條件的股票[/yellow]")

        # 6. 發送郵件
        mail_content = format_mail_content_with_days(
            momentum_stocks,
            rsi_stocks,
            macd_stocks,
            final_qualified_stocks,
            len(stock_index),
            updated_stock_data
        )

        sender_email = os.getenv("SENDER_EMAIL")
        app_password = os.getenv("APP_PASSWORD")
        receiver_email = os.getenv("RECIVER_EMAIL")
        send_mail(sender_email, app_password, receiver_email, mail_content)

    except Exception as e:
        console.print(f"[red]執行過程發生錯誤: {str(e)}[/red]")

    finally:
        console.print("\n[green]程式執行完成[/green]")


if __name__ == "__main__":
    try:
        print("程式開始執行...")
        print("時間範圍:", start_date, "到", end_date)
        print("-" * 50)
        main()
    except KeyboardInterrupt:
        print("\n程式被使用者中斷")
    except Exception as e:
        print(f"\n程式執行時發生未預期的錯誤: {str(e)}")
